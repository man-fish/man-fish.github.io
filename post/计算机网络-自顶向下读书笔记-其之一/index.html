<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>计算机网络 自顶向下读书笔记 其之一 | 于先森的个人博客</title>
    <meta property="og:title" content="计算机网络 自顶向下读书笔记 其之一 - 于先森的个人博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2020-01-31T03:55:51&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2020-01-31T03:55:51&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,于先森,javascript,nodejs,博客,服务器,前端,小程序">
    <meta name="description" content="计算机网络 自顶向下读书笔记 其之一">
        
    <meta name="author" content="inno">
    <meta property="og:url" content="https://patrick-prod.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%B9%8B%E4%B8%80/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-4031353640611810",
        enable_page_level_ads: true
    });
    </script>
    


    
    
        <link rel="stylesheet" href='/css/my.css'>
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://patrick-prod.github.io/">
                        于先森的个人博客
                    </a>
                
                <p class="description">渣本在校大学生/全栈开发，专注于JavaScript、Golang，科学技术是第一生产力。</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://patrick-prod.github.io/">首页</a>
                    
                    <a  href="https://patrick-prod.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://patrick-prod.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    
    <article class="post">
        <header>
            <h1 class="post-title">计算机网络 自顶向下读书笔记 其之一</h1>
        </header>
        <date class="post-meta meta-date">
            2020年1月31日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='https://patrick-prod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C'>计算机网络</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <h1 id="因特网概述">因特网概述</h1>
<h2 id="什么是因特网">什么是因特网？</h2>
<h4 id="从具体构成出发">从具体构成出发：</h4>
<p>因特网是一个世界范围的计算机网络，他是一个互联了编辑全球数十亿计算设备的网络。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213348.png" alt="image-20200121183049706"></p>
<p>对于因特网术语而言，所有设接入的设备都被称为<strong><code>主机(host)</code></strong>或者是<strong><code>端系统(end)</code></strong>，端系统通过<strong><code>通信链路(communication link)</code></strong>和<strong><code>分组交换机(packet switch)</code></strong>连接在一起。当一台端系统要向另一台端系统发送数据的时候 ，发送端将数据分段，并且为每段加上首部字段。由此形成的信息包称之为<strong><code>分组(packet)</code></strong>,分组交换机通过其一条通信链路接收到达的分组，并且从其另一条通信链路转发出去。两种比较常见的分组交换机包括<strong><code>路由器(roter)</code></strong>和<strong><code>链路层交换机(link-layer switch)</code></strong>,其中链路层交换机常用于接入网中，而路由器常用于网络核心。<strong>从发送端到接收端系统，一个分组所经过的所有通信链路和分组交换机成为通过该网络的<code>路径(route或者path)</code>。<strong>端系统一般通过</strong><code>因特网服务提供商(Internet Service Provider, ISP)</code></strong>接入因特网。因特网中的每一个部件，交换机，端系统都要遵循一系列<strong><code>协议(protocol)</code></strong>，这些协议控制这因特网中的信息发送和接受。</p>
<h4 id="从服务出发">从服务出发：</h4>
<p>人们在因特网上享受的应用程序涉及多个端系统之间的数据交换，所以他们被称为<strong><code>分布式应用服务(distributed app)</code></strong>,重要的是这些应用服务并不运行在分组交换机中反而是运行在处于网络边缘的端系统之中，那么一个端系统上的应用程序如何向另一个端系统上的应用程序发送数据呢，对于所有与因特网相连端系统提供了一个<strong><code>套接字接口(socket interface)</code></strong>,该系统规定了因特网上一个端系统向另一个端系统交付数据的方式。</p>
<h4 id="什么是协议">什么是协议：</h4>
<p><strong><code>协议(protocol)</code></strong>定义了在两个或者多个通信实体之间交换的报文格式和顺序，以及发送和接受一条报文或者其他事件所采取的动作。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213524.png" alt="image-20200121184504693"></p>
<h1 id="网络边缘">网络边缘</h1>
<p>端系统也称为主机，因为它们容纳(即运行)应用程序，如 <code>Web</code>浏览器程序、 <code>Web</code> 服务器程序、电子邮件阅读程序或电子邮件服务器程序等。本书通篇将交替使用主机和端系统这两个术语，即主机=端系统。主机又被进一步划分为两类:<strong><code>客户(client)</code></strong> 和 <strong><code>服务器 (server)</code></strong> 。 客户非正式地等同于桌面应用、移动PC 和智能手机等，而服务器非正式地等同于更为强大的机器，用于存储和发布 <code>Web</code>页面、流视频、中继电子邮件等。今天，大部分提供搜索结果、电子邮件、<code>Web</code> 页面和视频的服务器都属于大型<strong><code>数据中心(data center)</code></strong> 。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213624.png" alt="image-20200121184554470"></p>
<h2 id="接入网">接入网</h2>
<p><strong><code>接入网 ( access network)</code></strong>，这是指将端系统连接到其<code>边缘路由器(edge router)</code>的物理链路。边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<h3 id="家庭接人-dsl电缆-ftth拨号和卫星">家庭接人: DSL、电缆、 FTTH、拨号和卫星</h3>
<h5 id="dsl">DSL</h5>
<p>宽带住宅接人有两种最流行的类型:<strong><code>数字用户线 (Digital Subscriber Line , DSL)</code></strong>和电缆。住户通常从提供本地电话接人的本地电话公司处获得 <code>DSL</code> 因特网接人。 因此，当使用 <code>DSL</code> 时，用户的本地电话公司也是它的 <code>ISP</code>。</p>
<h5 id="电缆">电缆</h5>
<p>当 DSL 利用本地电话公司现有的本地电话基础设施时， <strong><code>电缆因特网接入 (cable lnlemet access)</code></strong> 利用了有线电视公司现有的有线电视基础设施。 电缆因特网接人需要特殊的调制解调器，称为<strong><code>电缆调制解调器 (cable modem)</code></strong> 。 如同 <code>DSL</code> 调制解调器，电缆调制解调器通常是一个外部设备，通过一个以太网端口连接到家庭 <code>PC</code> 。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213641.png" alt="image-20200121190028752"></p>
<h5 id="ftth">FTTH</h5>
<p><strong><code>光纤到户( Fiber To The Home ，FTTH)</code></strong> ,<code>FTTH</code> 概念简单，从本地中心局直接到家庭提供了一条光纤路径。  从本地巾心局到家庭有几种s竞争性的光纤分布方案。 最简单的光纤分布网络称为直接 光纤，从本地中心局到每户设置一根光纤。 更为一般的是，从中心局出来的每根光纤实际 上由许多家庭共享，直到相对接近这些家庭的位置，该光纤才分成每户一根光纤。 进行这 种划分的有两种竞争性的光纤分布体系结构:<strong><code>主动光纤网络 (Aclive Optical Network , AON)</code></strong>和<strong><code>被动光纤网络 (Presive Optical Network , PON)</code></strong>,其中AON 基本上就是交换因特网， <code>FTTH</code> 有潜力提供每秒千兆比特范围的因特网接人速率。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213655.png" alt="image-20200121185943043"></p>
<h3 id="企业和家庭接人以太网和-wifi">企业和家庭接人:以太网和 WiFi</h3>
<h5 id="以太网">以太网</h5>
<p>在公司和大学校园以及在越来越多的家庭环境中，通常是用<strong><code>局域网 (LAN)</code></strong> 将端用户 连接到边缘路由器。 尽管有许多不同类型的局域网技术，但是以太网到目前为止是当前公 司、大学和家庭网络中最为流行的接人技术。使用以太网接人，用户通常以 <strong>100Mbps</strong> 速率接人以太 网交换机，而服务器可能具有 <strong>lGbps 甚至lOGbps</strong> 的接人速率。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213708.png" alt="image-20200121185923457"></p>
<h5 id="wifi">WIFI</h5>
<p>越来越多的人从便携机、智能手机、平板电脑和其他设备无线接人因特网。在无线 LAN 环境中，无线用户从一个接人点发送/接收分组，该接人点与企业网连接(很可能包括有线以太网) ，该企业网再与有线因特网相连。一个无线 LAN 用户通常必须位于接人点的几十米范围内 。 基于 IEEE 802.11 技术的无钱 LAN 接人，更为通俗地称为 WiFi</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213720.png" alt="image-20200121190430127"></p>
<h5 id="常见家用网络">常见家用网络</h5>
<p>今天许多家庭正在将宽带住宅接人(即电缆调制解调器或DSL)与廉价的无线局域网技术结合起来，以产生强大的家用网络，图 1-9 显示了典型的家庭网络。 这个家庭网络组成如下:一台漫游的便携机和 l 台有线 PC; 一个与无线 PC 通信的基站(无线接人点); 一个提供与因特网宽带接人的电缆调制解调器; 以及一台互联了基站及带有电缆调制解调器的固定 PC 的路由器。该网络允许家庭成员经宽带接人因特网，其中一个成员可以在厨房、院子或卧室漫游上网。</p>
<h3 id="广域无线接人-3g-和-lte">广域无线接人: 3G 和 LTE</h3>
<h5 id="3g">3G</h5>
<p>3G 为分组交换广域 无线因特网接人提供了超过 1Mbps 的速率。 甚至更高速率的广域接人技术及第四代(4G) 广域无线网络已经在部署中。</p>
<h2 id="物理媒介">物理媒介</h2>
<p>考虑一个比特从一个端系统开始传输，通过一系列链路和路由器，到达另一个端系统。这个比特被传输许许多多次，源端系统首先传输这个比特，不久后其中的第一台路由器接收该比特、第一台路由器传输该比特，接着不久后第二台路由器接收该比特。 因此，这个比特当从源到目的地传输时，通过一系列&quot;传输器-接收器&quot;对。对于每个传输器-接收器，通过跨越一种<code>物理媒体 (physical medium)</code> 传播电磁波或光脉冲来发送该比特。</p>
<blockquote>
<p>物理媒体划分为两类:<strong><code>导引型媒体 (guided media)</code></strong> 和<strong><code>非导引型媒体(unguided media)</code></strong> 。 对于导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。 对于非导引型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道。</p>
</blockquote>
<h3 id="双绞铜线">双绞铜线</h3>
<p>双绞线由两根隔离的铜线组成，每根大 约 lmm 粗，以规则的螺旋形式排列着。这两根线被绞合起来，以减少来自邻近类似的双 绞线的电气干扰。通常许多双绞线捆扎在一起形成一根电缆，并在这些双绞线外面覆盖上保护性防护层。 一对电线构成了一个通信链路。<strong><code>无屏蔽双绞线 (Unsbielded TwisLed Pair, UTP)</code></strong> 常用在建筑物内的计算机网络中，即用于<strong><code>局域网 (LAN)</code></strong> 中。 目前局域网中的双绞 线的数据速率从 <code>10Mbps</code> 到<code>1OGbps</code> 所能达到的数据传输速率取决于线的粗细以及传输方和接收方之间的距离。</p>
<h3 id="同轴电缆">同轴电缆</h3>
<p>与双绞线类似，同轴电缆由两个铜导体组成，但是这两个导体是同心的而不是并行的。借助于这种结构及特殊的绝缘体和保护层，同轴电缆能够达到较高的数据传输速率。电缆电视系统最近与电缆调制解调器结合起来，为住宅区用户提供数<code>10Mbps</code> 速率的因特网接人。</p>
<h3 id="光纤">光纤</h3>
<p>光纤是一种细而柔软的、能够导引光脉冲的媒体，每个脉冲表示一个比特。一根光纤能够支持极高的比特速率，高达数十甚至数百<code>Gbps</code>它们不受电磁干扰，长达<code>100km</code>的光缆信号衰减极低，井且很难窃听。这些特征使得光纤成为长途引导型传输媒体，特别是跨海链路。</p>
<h3 id="陆地无线电信道">陆地无线电信道</h3>
<p>它不需要安装物理线路，并具有穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力，因而成为一种有吸引力的媒体。 无线电信 道的特性极大地依赖于传播环境和传输信号的距离。</p>
<p>陆地无线电信道能够大致划分为三类:一类运行在很短距离(如 1 米或 2 米) ;另一类 运行在局域，通常跨越数十到几百米;第三类运行在广域，跨越数万米。 个人设备如元线头 戴式耳机、键盘和医疗设备跨短距离运行，在无线 LAN 技术使用了局域无线电信道;蜂窝接入技术使用了广域无线电信道。</p>
<h3 id="卫星无线电信道">卫星无线电信道</h3>
<p>近地轨道卫星技术未来也许能够用于因特网接人。</p>
<h1 id="网络核心">网络核心</h1>
<p>即由互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213732.png" alt="image-20200122152106356"></p>
<h2 id="分组交换">分组交换</h2>
<p>在各种网络应用中，端系统彼此交换<strong><code>报文(message)</code></strong>。 报文能够包含协议设计者需要的任何东西。为了从源端系统向目的端系统发送一个报文，将长报文划分为较小的数据块，称之为<strong><code>分组(packet)</code></strong> 。在源和目的之间，每个分组都通过<strong><code>通信链路</code></strong>和<strong><code>分组交换机 (packet switch) (交换机主要有两类: 路由器和链路层交换机)</code></strong>传送。分组以等于该链路最大传输速率的速度传输通过通信链路。 因此，如果某源端系统或分组交换机经过一条链路发送一个<code>L比特</code>的分组，链路的传输速率为 <code>R 比特/秒</code>，则传输该分组的时间为 <code>L/R 秒</code>。</p>
<p>接下来我们详细的描述一下分组交换原则</p>
<h3 id="存储转发传输">存储转发传输</h3>
<p>多数分组交换机在链路的输入端使用<strong><code>存储转发传输(store and forward packet switching)</code></strong> 机制，当路由器已经接收完了该分组的所有比特后，它才能开始向出链路传输(即&quot;转发&rdquo;)该分组。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213745.png" alt="image-20200122152730066"></p>
<p>为了深刻领悟得储转发传输，我们现在计算一下从源开始发送分组到目的地收到整个分组所经过的时间。源在时刻<code>0</code>开始传输，在时刻 <code>L/R 秒</code>，因为该路由器刚好接收到整个分组，所以它能够朝着目的地向出链路开始传输分组;在时刻 <code>2L/R</code>，路由器已经传输了整个分组，并且整个分组已经被目的地接收。 所以，总时延是 <code>2L/R</code>。如果交换机一旦比特到达就转发比特(不必首先收到整个分组) , 则因为比特没有在路由器保持，总时延将是<code>L/R</code>。</p>
<blockquote>
<p><a href=""><strong>上面L表示bit总量，R表示Rmbps，若一条线路的传输速率为1mbps，传输速率于距离看作无关，只与bit量有关。</strong></a></p>
</blockquote>
<p>现在我们来计算从源开始发送第一个分组直到目的地接收到所有三个分组所需的时间，与前面一样，在时刻<code>L/R</code>，路由器开始转发第一个分组，而在时刻 <code>L/R</code>， 源也开始发送第二个分组，因为它已经完成了发送整个第一个分组。因此，在时刻 <code>2L/R</code>， 目的地已经收到第一个分组并且路由器已经收到第二个分组。 类似地，在时刻 <code>3L/R</code>， 目的地已经收到前两个分组并且路由器已经收到第三个分组。最后，在时刻 <code>4L/R</code>， 目的地已经收到所 有 <code>3</code> 个分组。</p>
<p>我们现在来考虑通过由 <code>N</code> 条速率均为 <code>R</code> 的链路组成的路径(所以，在源和目的地之间有<code>N-1</code>台路由器) ，从源到目的地发送一个分组的总体情况。 应用如上相同的逻辑，我们看到端到端时延是:
$$
d_{end~to~end} = N\frac{L}{R}
$$</p>
<h3 id="排队时延和分组丢失">排队时延和分组丢失</h3>
<p>每个分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个 <strong><code>输出缓存 (output buffer) (也称为输出队列 output queue)</code></strong> ，它用于存储路由器准备发往那条链路的分组。 该输出缓存在分组交换中起着重要的作用。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在该输出缓存中等待。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213755.png" alt="image-20200122154617560"></p>
<p>除了存储转发时延以外，分组还要承受输出缓存的<strong><code>排队时延 (queue delay)</code></strong> 。 这些时延是变化的，变化的程度取决于网络中的拥塞程度。 因为缓存空间的大小是有限的， 一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。此情况下，将出现分组丢失<strong><code>丢包(packet lost)</code></strong> ，刚到达的分组或已经排队的分组之一将被丢弃。</p>
<h3 id="转发表和路由选择协议">转发表和路由选择协议</h3>
<p>路由器从与它相连的一条通信链路得到分组，将其向与它相连的另一 条通信链路转发。但是该路由器怎样决定它应当向哪条链路进行转发呢?</p>
<p>在因特网，每个端系统具有一个称为 IP 地址的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的<code>IP地址</code>。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个<strong><code>转发表 (forwarding table)</code></strong>，用于将目的地址(或目的地址的一部分)映射成为输出链路。 当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。路由器则将分组导向该出链路。此外因特网具有一些特殊的<strong><code>路由选择协议 (routing protocol)</code></strong>，用于自动地设置这些转发表。例如，一个路由选择协议可以决定从每台路由器到每个目的地的最短路径，并使用这些最短路径结果来配置路由器中的转发表。</p>
<h2 id="网络的网络">网络的网络</h2>
<p>端系统经过一个接人 <code>ISP</code> 与因特网相连。 该<strong>接入ISP</strong> 能够提供有线或无线连接，使用了包括 <code>DSL、电缆、 FITH、 WiFi 和蜂窝等多种接入技术</code>。  但为端用户和内容提供商提供与接人 ISP 的连接仅解 决了连接难题中的很小一部分，因为因特网是由数以亿计的用户构成的。要解决这个难题，接人<code>lSP</code> 自身必须互联。 通过创建网络的网络可以做到这一点，理解这个短语是理解因特网的关键。年复一年，构成因特网的&quot;网络的网络&quot;已经演化成为一个非常复杂的结构。 这种演化很大部分是由经济和国家策略驱动的，而不是由性能考虑驱动的。</p>
<h3 id="网络结构-0">网络结构 0</h3>
<p>使每个接人<code>ISP</code> 直接与每个其他接人 ISP 连接。 当然，这样的网状设计 对于接人 <code>ISP</code> 费用太高，因为这将要求每个接人 ISP 与世界上数十万个其他接人 <code>ISP</code> 有一 条单独的通信链路。</p>
<h3 id="网络结构-1">网络结构 1</h3>
<p>用单一的全球承载 <code>ISP</code> 互联所有接人 <code>ISP</code>。 我们 假想的<code>全球承载 ISP</code> 是一个由路由器和通信链路构成的网络，该网络不仅跨越全球，而且 至少具有一个路由器靠近数十万接人 <code>ISP</code> 中的每一个 当然，对于全球承载 <code>ISP</code>，建造这 样一个大规模的网络将耗资巨大。 为了有利可图，自然要向每个连接的接人 <code>ISP</code> 收费，其价格反映(并不一定正比于)一个接人 <code>ISP</code> 经过全球 <code>ISP</code> 交换的流量大小。 因为接人 <code>ISP</code> 向全球承载 <code>ISP</code> 付费，故接人 ISP 被认为是<strong><code>客户(customer)</code></strong> .而全球承载 <code>ISP</code> 被认为是<strong><code>提供商(provider)</code></strong> 。</p>
<h3 id="网络结构-2">网络结构 2</h3>
<p>它由数十万接人 <code>ISP</code> 和多个全球承载 <code>ISP</code> 组成。 接人 <code>ISP</code> 无疑喜欢网络结构 2 胜过喜欢网络结构 1 , 因为它们现在能够根据价格和服务的函数，在多个竞争的全球承载提供商之间进行选择。值得注意的是，这些全球承载 <code>ISP</code> 之间必须是互联的。不然的话，与某个全球承载 <code>lSP</code> 连接的接人 ISP 将不能与连接到其他全球承载 <code>ISP</code> 的接人 <code>ISP</code> 通信。</p>
<h3 id="网络结构-3">网络结构 3</h3>
<p>在任何给定的区域，可能有一个<strong><code>区域 ISP (reginal ISP)</code></strong>，区域中的接入<code>lSP</code>与之连接。每个区域<code>lSP</code> 则与第一层 <code>ISP</code> (tier-1 ISP) 连接。 第一层 <code>ISP</code> 类似于我们假想的全球承载 <code>ISP</code> 尽管第一层 <code>ISP</code> 不 是在世界上每个城市巾都存在，但它确实存在。 有大约十几个第一层 <code>ISP</code>，包括<code>Level3 通信、 AT&amp;T、 SprinL 和 NTT</code>。 有趣的是，没有组织正式认可第一层状态。 俗话说:如果必须 问你是有是一个组织的成员，你可能不是。</p>
<h3 id="网络结构-35">网络结构 3.5</h3>
<p>为了建造一个与今天因特网更为相似的网络，我们必须在等级结构的网络结构3上增加<strong><code>存在点 (Point of Presence, PoP)</code></strong> 、多宿、对等和<strong><code>因特网交换点 (Jnternet exchange point , IXP)</code></strong> PoP 存在于等级结构的所有层次，但底层(接人 <code>ISP</code>) 等级除外。一个<code>PoP</code> 只是提 供商网络巾的一台或多台路由器(在相同位置)群组，其中客户ISP 能够与提供商<code>ISP</code>连 接。对于要与提供商<code>PoP</code> 连接的客户网络，它能从第三方通信提供商租用高速链路直接将它的路由器之一连接到位于该<code>PoP</code> 的一台路由器。任何 <code>ISP</code> (除了第一层 <code>ISP</code>)可以选择 为<code>多宿 (multi-home)</code>，即可以与两个或更多提供商<code>ISP</code> 连接。例如，一个接人 ISP 可能与 两个区域 <code>ISP</code> 多宿，或者可以与两个区域 <code>ISP</code> 多宿，也可以与多个第一层 <code>ISP</code> 多宿。当一个 <code>ISP</code> 多宿时，即使它的提供商之一出现故障，它仍然能够继续发送和接收分组。</p>
<h3 id="网络结构4">网络结构4</h3>
<p>客户 <code>ISP</code> 向它们的提供商 ISP 付费以获得全球因特网互联能力客户 <code>ISP</code> 支付给提供商 <code>ISP</code> 的费用数额反映了它通过提供商交换的流量，为了减少这些费用，位于相同等级结构层次的邻近一对 ISP 能够对等。当两个 <code>ISP</code> 对等时，通常不进行结算，即任一个 <code>ISP</code> 不向其对等付费如前面提到的那样，第一层 <code>ISP</code> 也与另一个第一层 <code>ISP</code>等，它们之间无结算。沿着这些相同路线，地方公司创建一个<code>因特网交换点 (InLemet Exchange Point)</code> ,<code> IXP</code>是一个汇合点，多个 <code>ISP</code> 能够在这里共同对等。在今天的因特网中有大约300个<code>IXP</code>。我们称这个系统为生态系统，由接人<code>ISP</code>、以区域<code>ISP</code>、第一层<code>ISP</code>、<code>POP</code>、多宿、对等和 <code>IXP</code> 组成，这个系统作为网络结构 4。</p>
<h3 id="网络结构5">网络结构5</h3>
<p>我们现在最终到达了网络结构5，它通过在顶部增加<strong><code>内容提供商网络 (conLent provider net work)</code></strong> 构建而成。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213822.png" alt="image-20200123162335731"></p>
<h1 id="分组交换网中的时延和丢包吞吐量">分组交换网中的时延和丢包、吞吐量</h1>
<p>计算机网络必定要限制在端系统之间的吞吐量(每秒能够传送的数据盘) ，在端系统之间引入时延，而且实际上能够丢失分组。</p>
<h2 id="时延和丢包">时延和丢包</h2>
<h3 id="分组交换网中的时延概述">分组交换网中的时延概述</h3>
<p>当分组从一个<strong>结点(主机或路由器)<strong>沿着·<strong>后继结点(主机或路由器)</strong>，该分组在沿途的每个结点经受了几种不同类型的时延。这些时延最为重要的是</strong>结点处理时延(nodal processing delay)</strong>、<strong>排队时延(queuing delay)</strong>、<strong>传输时延(ansmission delay)</strong> 和<strong>传播时延 (propagalÍon delay)</strong>，这些时延总体累加起来是<strong>结点总时延(nodal delay)</strong> 。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213958.png" alt="image-20200123164430867"></p>
<h3 id="时延的类型">时延的类型</h3>
<p><strong>传输的条件：</strong></p>
<ul>
<li>路由器 A 具有通往路由器 B 的出链路。</li>
<li>当在该链路没有其他分组正在传输并且没有其他分组排在该队列前面时，才能在这条链路上传输该分组。</li>
</ul>
<h4 id="处理时延">处理时延</h4>
<p>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。高速路由器的处理时延通常是微秒或更低的数量级。在这种结点处理之后，路由器将该分组引向通往路由器 B 链路之前的队列。</p>
<h4 id="排队时延">排队时延</h4>
<p>在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。</p>
<h4 id="传输时延">传输时延</h4>
<p>假定分组以先到先服务方式传输，这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。用 <code>L</code> 比特表示该分组的长度，用 <code>R bps (即 b/s)</code> 表示从路由器 A 到路由器 B 的链路传输速率。 例如，对于一条 <code>10Mbps</code> 的以太网链路，速率<code>R = 10Mbps</code>; 对于 <code>100Mbps</code> 的以太网链路，速率 <code>R = 100Mbps</code>，传输时延是<code>L/R</code>。这是将所有分组的比特推向链路所需要的时间。</p>
<h4 id="传播时延">传播时延</h4>
<p>从该链路的起点到路由器 B 传播所需要的时间是传播时延。 该比特以该链路的传播速率传播。 该传播速率取决于该链 路的物理媒体(即光纤、双绞铜线等)，其速率等于或略小于光速。该传播时延等于两台路由器之间的距离除以传播速率。即传播时延是d/s，其中 d 是路由器 A 和路由器 B 之间的距离，s是该链路的传播速率。 一旦该分组的最后一个比特传播到结点 B ，该比特及前面的所有比特被存储于路由器 B。 整个过程将随着路由器 B 执行转发而持续下去。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213951.png" alt="image-20200123164444972"></p>
<h4 id="总结">总结</h4>
<p>如果我们令<strong><code>d(prod)、d(queue)、d(trans)、d(prop)</code></strong>分别表示处理时延、排队时延、传输时延和传播时延，则结点的总时延由下式给定:
$$
d_{nodal}~=~d_{prod}~+~d_{queue}~+~d_{trans}~+~d_{prop}
$$
处理时延<code>d(proc)</code>通常是微不足道的，然而，它对一台路由器的最大吞吐量有重要影响，最大吞吐量是一台路由器能够转发分组的最大速率。</p>
<h3 id="排队时延和丢包">排队时延和丢包</h3>
<p><strong>排队时延</strong></p>
<p>结点时延的最为复杂和有趣的成分是排队时延 <code>d(queue)</code>，例如，如果 10 个分组同时到达空队列，传输的第一个分组没有排队时延，而传输的最后一个分组将经受相对大的排队时延(这时它要等待其他9个分组被传输)。因此，当计算排队时延时，人们通常使用统计量测度，如平均排队时延、排队时延的方差和排队时延超过某些特定值的概率。</p>
<p>为了更深入地领会某些要点，令 <code>α</code> 表示<strong><code>分组到达队列的平均速率 (α 的单位是分组/ 秒，即 pkt/s)</code></strong> 。 前面讲过 <code>R</code> 是传输速率，即从队列中<strong><code>推出比特的速率(以 bps 即 b/s 为单位)</code></strong> 。为了简单起见，也假定所有分组都是由 <code>L</code> 比特组成的。 则比特到达队列的平均速率 是 <code>Lα bps</code>。 最后，假定队列非常大，因此它基本能容纳无限数量的比特。<code>比率 Lα/R</code>  称为<strong><code>流量强度( traffic intensity)</code></strong>，它在估计排队时延的范围方面经常起着重要的作用。 如果 <code>La/R &gt; 1</code> ，则 比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，该队列趋向于无界增加，并且排队时延将趋向无穷大！因此流量工程中的一条金科玉律是：<strong>设计系统时流量强度不能大于 1</strong> 。</p>
<p><strong>丢包</strong></p>
<p>我们已经假设队列能够容纳无穷多的分组。在现实中，一条链路前的队列只有有限的容量，尽管<strong>排队容量极大地依赖于路由器设计和成本</strong>。 因为该排队容量是有限的，随着流量强度接近 1 ，排队时延并不实际趋向无穷大。 相反，到达的分组将发现 一个满的队列。 由于没有地方存储这个分组，路由器将<code>丢弃(drop)</code> 该分组，即该分组将会<code>丢失(lost)</code> 。</p>
<h3 id="端到端时延">端到端时延</h3>
<p>我们现在考虑从源到目的地的总时延。 为了能够理解这个概念，假定在源主机和日的主机之间有<code>N-1</code> 台路由器。 我们还要假设该网络此时是无拥塞的(因此排队时延是微不足道的) ，在每台路由器和源主机上的处理时延是<code>d(proc)</code>，每台路由器和源主机的输出速率是<code>R bps</code>，每条链路的传播时延是 <code>d(prop)</code>。 结点时延累加起来，得到端到端时延:
$$
d_{end~to~end}~=~N*(d_{prod}~+~d_{trans}~+~d_{prop})
$$</p>
<h2 id="计算机网络中的吞吐量">计算机网络中的吞吐量</h2>
<h3 id="吞吐量的定义">吞吐量的定义</h3>
<p>为了定义吞吐量，考虑从<strong>主机A</strong>到<strong>主机B</strong>跨越计算机网络传送个大文件。 例如，也许是从一个<strong>P2P文件</strong>共享系统中的一个对等方向另一个对等方传送一个大视频片段。在任何时间瞬间的<strong><code>瞬时吞吐量( instantaneous throughput)</code></strong> 是主机B接收到该文件的速率(以<strong>bps</strong>计)。如果该文件由F比特组成，主机<strong>B</strong>接收到所有<strong>F</strong>比特用去<strong>T</strong>秒，则文件传送的<strong><code>平均吞吐量(average throughput)</code></strong>是<strong><code>F/T bps</code></strong>。对于某些应用程序如因特网电话，希望具有低时延和在某个阈值之上的一致的瞬时吞吐量。</p>
<p>为了进一步深人理解吞吐量这个重要概念，我们考虑几个例子。上图显示了服务器和客户这两个端系统，它们由两条通信链路和一台路由器相连。考虑从服务器传送一个文件到客户的吞吐量。令<strong>Rs</strong>表示服务器与路由器之间的链路速率、<strong>Rc</strong>表示路由器与客户之间的链路速率。假定在整个网络中只有从这台服务器到那台客户的比特在传送。我们可以想象比特是流体，通信链路是管道。显然，这台服务器不能以快于<strong>Rsbps</strong>的速率通过其链路注人比特，这台路由器也不能以快于<strong>Rc bps</strong>的速率转发比特。如果<strong>Rs &lt;Rc</strong>，则由该服务器注人的比特将顺畅地通过路由器“流动&rdquo;，并以速率<strong>Rc bps</strong>到达客户，给定了<strong>Rsbps</strong>的吞吐量。在另方面，如果<strong>Rc &lt; Rs</strong>，则该路由器将不能够以接收它们那样快的速率来转发比特。在这种情况下，比特将以速率<strong>Rs</strong>离开该路由器，从而得到端到端吞吐量<strong>Rs</strong>。(还要注意的是，如果比特继续以速率<strong>Rs</strong>到达该路由器，继续以<strong>Rc</strong>离开路由器的话，在该路由器中等待传输给客户的积压比特将不断增加，这是一种非常不希望的情况!)。因此，对于这种简单的两链路的网络，其吞吐量是<strong>min{Rc，Rs}</strong>，这就是说，它是<strong><code>瓶颈链路(bot一tleneck link)</code></strong>的传输速率。在决定了吞吐量之后，我们现在近似地得到从服务器到客户传输一个<strong>F</strong>比特的大文件所需要的时间是<strong>F/min{Rc，Rs}</strong>。对于一个特定的例子，假定你正在下载一个<strong>F=32x10^6</strong>比特的MP3文件，服务器具有<strong>Rc =2Mbps</strong>的传输速率，并且你有一条<strong>Rs=1Mbps</strong>的接人链路。则传输该文件所需的时间是32秒。当然，这些吞吐量和传送时间的表达式仅是近似的，因为它们并没有考虑分组层次和协议的问题。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213916.png" alt="image-20200124192829603"></p>
<p>下图此时显示了在服务器和客户之间具有N条链路的一个网络，这<strong>N</strong>条链路的传输速率分别是<strong>R1,R2,,,,Rx</strong>。应用与对两条链路网络的分析相同的方法，我们发现从服务器到客户的文件传输的吞吐量是<strong>min{R1, R2, .., RN</strong>}。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213925.png" alt="image-20200124193451821"></p>
<p>考虑从服务器向客户的文件传送的吞吐量。服务器以速率为<strong>Rs</strong>的接人速率与网络相连，且客户以速率为<strong>Rc</strong>的接入速率与网络相连。现在假定在计算机网络核心中的所有链路具有非常高的传输速率，即该速率比<strong>Rc和Rs</strong>要高得多。目前因特网的核心的确过度装备了高速率的链路，从而很少出现拥塞。同时假定在整个网络中发送的比特都是从该服务器到该客户。在这个例子中，因为计算机网络的核心就像一个宽大的管子，所以比特从服务器向目的地的流动速率仍是Rc和Rs中的最小者，即<strong>吞吐量=min{Rs, Rc}</strong>。因此，在今天因特网中对吞吐量的限制因素通常是接人网。</p>
<h1 id="层次协议和服务模型">层次协议和服务模型</h1>
<blockquote>
<p>对于大而复杂且需要不断更新的系统，改变服务的实现而不影响该系统其他组件是分层的另一个重要优点。</p>
</blockquote>
<h2 id="协议分层">协议分层</h2>
<p>网络设计者以<code>分层 (layer)</code> 的方式组织协议以及实现这些协议的网络硬件和软件。每个协议属于这些层次之一，我们再次关注某层向它的上一层提供的<code>服务(service)</code>，即所谓一层的<code>服务模型 (service model)</code>。</p>
<p>一个协议层能够用软件、硬件或两者的结合来实现。诸如 <strong>HTTP</strong> 和 <strong>SMTP</strong> 这样的应用层协议几乎总是在端系统中用软件实现的，运输层协议也是如此。一个第 <strong>n</strong> 层协议也分布在构成该网络的端系统、分组交换机和其他组件中。 这就是说，第 n 层协议的不同部分常常位于这些网络组件的各部分中。</p>
<p>不过分层的一个潜在缺点是一层可能冗余较低层的功能。例如，许多协议横在基于每段链路和基于端到端两种情况下，都提供了差错恢复。第二种潜在的缺点是某层的功能可能需要仅在其他某层才出现的信息(如时间戳值)，这违反了层次分离的目标。</p>
<p>将这些综合起来，各层的所有协议被称为<code>协议枝 (protocol stack)</code> 。因特网的协议由 5 个层次组成:<code>物理层、链路层、网络层、运输层和应用层</code>。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213935.png" alt="image-20200125015539920"></p>
<h3 id="应用层">应用层</h3>
<p>应用层是网络应用程序及它们的应用层协议存留的地方。因特网的应用层包括许多协议，例如 <strong>HTTP (它提供了 Web 文档的请求和传送)</strong>， <strong>SMTP (它提供了电子邮件报文的传输)</strong> 和 <strong>FTP (它提供两个端系统之间的文件传送)</strong> 。</p>
<p>应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息的分组。我们把这种位于应用层的信息分组称为<code>报文 (message)</code> 。</p>
<h3 id="运输层">运输层</h3>
<p>因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，有两个运输协议，即 <strong>TCP</strong> 和 <strong>UDP</strong>，利用其中的任一个都能运输应用层报文。 <strong>TCP</strong> 向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制(即发送方 /接收方速率匹配) , TCP 也将长报文划分为短报文，并提供拥塞控制机制，因此当网络拥塞时，源抑制其传输速率。<strong>UDP 协议</strong>向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。在本书中，我们把运输层分组称为<code>报文段( segment) </code>。</p>
<h3 id="网络层">网络层</h3>
<p>因特网的网络层负责将称为<code>数据报(datagram)</code>的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网<strong>运输层协议 (TCP 或 UDP)</strong> 向网络层递交运输层报文段和目的地址。</p>
<p>因特网的网络层包括著名的 <strong>IP</strong> 协议，该协议定义了在数据的各个字段以及端系统和路由器如何作用于这些字段。因为仅有一个 <strong>IP</strong> 协议，所有具有网络层的因特网组件必须运行 <strong>IP</strong> 协议。 尽管网络层包括了 <strong>IP</strong> 协议和一些路由选择协议，但通常把它简单地称为 <strong>lP</strong> 层。</p>
<h3 id="链路层">链路层</h3>
<p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个结点(主机或路由器)移动到路径上的下一个结点，网络层必须依靠链路层的服务。特别是在每个结点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个结点。在下个结点，链路层将数据报上传给网络层。</p>
<p>由链路层提供的服务取决于应用于该链路的特定链路层协议。值得注意的是这种传递服务不同于<strong>TCP协议</strong>的可靠传递服务，<strong>TCP协议</strong>保证一个端到一个端的可交付型。链路层的例子包括<code>以太网、WiFi 和电缆接入网的 DOCS1S 协议</code>。网为数据报从源到目的地传送通常需要经过几条链路，一个数据报可能被沿途不同链路上的不同链路层协议处理。同时，我们把链路层分组称为<code>帧(frame)</code> 。</p>
<h3 id="物理层">物理层</h3>
<p>虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素(分组交换机，端系统)，而物理层的任务是将该帧中的一个一个比特从一个结点移动到下一个结点在这层中的协议仍然是链路相关的，并且进一步与该链路(例如:双绞铜线、 单模光纤)的实际传输媒体相关。例如，以太网具有许多物理层协议:一个是关于双绞铜线的，另一个是关于同轴电缆的，还有一个是关于光纤的，等等。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。</p>
<h3 id="osi-模型">OSI 模型</h3>
<p>讨论过因特网协议校后，我们应当提及它不是唯一的协议栈。 特别是在 20 世纪 70 年代后期，<code>国际标准化组织 (IS0)</code> 提出计算机网络应组织为大约 7 层，称为<strong>开放系统互连(OSI) 模型</strong> 。OSI 参考模型的 7 层是:<code>应用层、表示层、会话层、运输层、网络层、数据链路层和物理层</code>。因特网缺少了在OSI 参考模型中建立的两个层次，这两个层次留给应用程序开发者处理。 应用程序开发者决定一个服务是再是重要的，如果该服务重要，应用程序开发者就应该在应用程序中构建该功能。</p>
<h2 id="封装">封装</h2>
<p>路由器和链路层交换机都是分组交换机。与端系统类似，路由器和链路层交换机以多层次的方式组织它们的网络硬件和软件。而路由器和链路层交换机并不实现协议楼中的所有层次。如图所示，链路层交换机实现了第一层和第二层;路由器实现了第一层到第三层。例如，这意味着因特网路由器能够实现 IP 协议(一种第三层协议)，而链路层交换机则不能。我们将在后面看到，尽管链路层交换机不能识别 IP 地址，但它们能够识别第二层地址，如以太网地址。值得注意的是，主机实现了所有 5 个层次，这与因特网体系结构将它的复杂性放在网络边缘的观点是一致的。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213941.png" alt="image-20200125021337795"></p>
<p><code>封装( encapsulation)</code> 。在发送主机端，一个<code>应用层报文 (application-layer message)</code> 被传送给运输层。在最简单的情况下，运输层收取到报文并附上附加信息)，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了<code>运输层报文段(transportlayer segment)</code>。运输层报文段因此封装了应用层报文。附加的信息也许包括了下列信息: 如允许接收端运输层向上向适当的应用程序交付报文的信息。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，产生了网络层数据报<code>(network-layer dagram) </code>。该数据报接下来被传递给链路层，链路层(向然而然地)增加它自己的链路层首部信息并创建<code>链路层帧 (link-layer frame) </code>。所以，我们看到在每一层，一个分组具有两种类型的字段:首部宇段和<code>有效载荷字段 (payload field)</code> 。有效载荷通常是来自上一层的分组。</p>
<p>封装的过程能够比前面描述的更为复杂。 例如，一个大报文可能被划分为多个运输层 的报文段(这些报文段每个可能被分为多个网络层数据报) 。 在接收端，则必须从其连 续的数据报中重构这样一个报文段。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://patrick-prod.github.io/">inno</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://patrick-prod.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%B9%8B%E4%B8%80/">https://patrick-prod.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%B9%8B%E4%B8%80/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
    </ul>
</div>
<br/>



        


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://patrick-prod.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80'>编程基础</a></li>
                
                <li><a href='https://patrick-prod.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C'>计算机网络</a></li>
                
                <li><a href='https://patrick-prod.github.io/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B'>自顶向下</a></li>
                
            </ul>
            
        </div>
    </article>
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://patrick-prod.github.io/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://patrick-prod.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://patrick-prod.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%B9%8B%E4%B8%80/" title="计算机网络 自顶向下读书笔记 其之一">计算机网络 自顶向下读书笔记 其之一</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li><a href="https://patrick-prod.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络 (1)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://patrick-prod.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a>
    
    <a href="https://patrick-prod.github.io/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/">自顶向下</a>
    
    <a href="https://patrick-prod.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.fazero.me/" title="fazero的博客">fazero的博客</a>
        </li>
        
        <li>
            <a target="_blank" href="https://www.iamasd.cn/" title="iamasd的博客">iamasd的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://patrick-prod.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div class="container">
        &copy; 2020 <a href="https://patrick-prod.github.io/">于先森的个人博客 By inno</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/flysnow-org/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>