<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 于先森的个人博客</title>
    <link>https://patrick-prod.github.io/post/</link>
    <description>Recent content in Posts on 于先森的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 31 Jan 2020 22:00:26 +0800</lastBuildDate>
    
	<atom:link href="https://patrick-prod.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go校验层go Validator</title>
      <link>https://patrick-prod.github.io/post/go%E6%A0%A1%E9%AA%8C%E5%B1%82go-validator/</link>
      <pubDate>Fri, 31 Jan 2020 22:00:26 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/go%E6%A0%A1%E9%AA%8C%E5%B1%82go-validator/</guid>
      <description>最近在使用iris框架开发应用的时候，框架本身没有提供优秀的校验层，于是找到了一个第三方库go-validator来搭建校验层。 安装 Go get 获取依赖。 1 go get gopkg.in/validator.v2 Import the package into your own code. 1 2 3 import ( &amp;#34;gopkg.in/validator.v2&amp;#34; ) 使用 定义校验规则 自定义你的校验规则，同时可以使用匿名继承的方式定义结构体。 1 2 3 4 5 6 7 8 9 10 type LoginValidator</description>
    </item>
    
    <item>
      <title>Go处理token</title>
      <link>https://patrick-prod.github.io/post/go%E5%A4%84%E7%90%86token/</link>
      <pubDate>Fri, 31 Jan 2020 21:34:13 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/go%E5%A4%84%E7%90%86token/</guid>
      <description>搭建网站时我们经常使用JWT做用户鉴权，在golang中我们🉑️以通过jwt-go的第三方库来为我们实现。 常见的处理流程： 从request获取tokenstring，可能是通过cookie携带，也可能是从lacalstorage读取并写入请求头。 将tokenstring转化为未解</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Fri, 31 Jan 2020 09:04:57 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>前言✍ 动态规划（Dynamic Programming），求解的问题必须有两个性质：最优子结构和子问题重叠，和分治法的思想相同，动态规划的思路也是先将大问题分解成若干个规模相同的子问题，但是动态规划的问题是重叠的，想要理解一个动态规划就要理解一个它的核心，动态规划算法的核心是下面的</description>
    </item>
    
    <item>
      <title>动态规划模型</title>
      <link>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 31 Jan 2020 08:33:26 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</guid>
      <description>线性模型🌾 两个变量之间存在一次方函数关系，就称它们之间存在线性关系。 在线性结构上进行状态转移DP，统称线性DP，注意问题中的未知数只有两个那就是n和f(n)，比如说分金币问题中的coins总数和charge次数。下面拿实际问题来举例子。 注意：已知量数组不属于变量，比如说金币面额。</description>
    </item>
    
    <item>
      <title>贪心算法</title>
      <link>https://patrick-prod.github.io/post/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 31 Jan 2020 08:18:46 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>简介 贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 例子:最小生成树的算法 (Prim MST</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>https://patrick-prod.github.io/post/%E9%80%92%E5%BD%92/</link>
      <pubDate>Fri, 31 Jan 2020 08:12:41 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E9%80%92%E5%BD%92/</guid>
      <description>定义 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。在算法中递归应用之广毋庸置疑回溯，分治，动态规划，贪心算法中都推导的过程中可能用到递归算法。比如实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在： 递归就是有去（递去</description>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link>https://patrick-prod.github.io/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 31 Jan 2020 08:11:15 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>回溯算法实际上一个类似枚举的搜索尝试过程，是穷举的子集，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 所谓的回溯，其实就是利用了for循环的执行先后顺序，比如同一层循环中，某一次循环断裂掉了，那么下一次循环一定会执行，也就是所谓的回溯</description>
    </item>
    
    <item>
      <title>自顶向下读书笔记 层次协议</title>
      <link>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B1%82%E6%AC%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 31 Jan 2020 07:31:27 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%B1%82%E6%AC%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>对于大而复杂且需要不断更新的系统，改变服务的实现而不影响该系统其他组件是分层的另一个重要优点。 协议分层 网络设计者以分层 (layer) 的方式组织协议以及实现这些协议的网络硬件和软件。每个协议属于这些层次之一，我们再次关注某层向它的上一层提供的服务(service)，即所谓一层的服务模型 (service mod</description>
    </item>
    
    <item>
      <title>自顶向下读书 分组交换</title>
      <link>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</link>
      <pubDate>Fri, 31 Jan 2020 07:30:48 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2/</guid>
      <description>计算机网络必定要限制在端系统之间的吞吐量(每秒能够传送的数据盘) ，在端系统之间引入时延，而且实际上能够丢失分组。 时延和丢包 分组交换网中的时延概述 当分组从一个结点(主机或路由器)沿着·后继结点(主机或路由器)，该分组在沿途的每个结点经受了几种不同类型的时延。这些时延最为重要的是结点</description>
    </item>
    
    <item>
      <title>自顶向下读书笔记 网络核心</title>
      <link>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/</link>
      <pubDate>Fri, 31 Jan 2020 07:30:12 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/</guid>
      <description>即由互联因特网端系统的分组交换机和链路构成的网状网络。 分组交换 在各种网络应用中，端系统彼此交换报文(message)。 报文能够包含协议设计者需要的任何东西。为了从源端系统向目的端系统发送一个报文，将长报文划分为较小的数据块，称之为分组(packet) 。在源和目的之间，每个分组都通</description>
    </item>
    
    <item>
      <title>自顶向下读书笔记 网络边缘</title>
      <link>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98/</link>
      <pubDate>Fri, 31 Jan 2020 07:30:04 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98/</guid>
      <description>端系统也称为主机，因为它们容纳(即运行)应用程序，如 Web浏览器程序、 Web 服务器程序、电子邮件阅读程序或电子邮件服务器程序等。本书通篇将交替使用主机和端系统这两个术语，即主机=端系统。主机又被进一步划分为两类:客户(client) 和 服务器 (server) 。 客户非正式地等同于桌面应用、移动PC 和智</description>
    </item>
    
    <item>
      <title>自顶向下读书笔记</title>
      <link>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 31 Jan 2020 03:55:51 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>计算机网络是服务器编程的基础，以下是博主阅读《计算机网络-自顶向下》的读书笔记。 第一部分：因特网 因特网概述 网络边缘 网络核心 层次协议 分组交换</description>
    </item>
    
    <item>
      <title>自顶向下读书笔记 因特网概述</title>
      <link>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Fri, 31 Jan 2020 03:55:51 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9B%A0%E7%89%B9%E7%BD%91%E6%A6%82%E8%BF%B0/</guid>
      <description>什么是因特网？ 从具体构成出发： 因特网是一个世界范围的计算机网络，他是一个互联了编辑全球数十亿计算设备的网络。 对于因特网术语而言，所有设接入的设备都被称为主机(host)或者是端系统(end)，端系统通过通信链路(communication link)和分组交换机(packet swi</description>
    </item>
    
  </channel>
</rss>