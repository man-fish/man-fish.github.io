<!DOCTYPE html>
<html lang="en">
<head>

  
  <meta charset="utf-8">
  <title>自顶向下读书 分组交换 - Fish blog ø</title>
  <meta name="description" content="自顶向下读书 分组交换">
  <meta name="author" content="FishMan">

  
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="http://blog.innoweb.cn/css/fonts.css">
  
  
  <link rel="stylesheet" href="https://unpkg.com/purecss@0.6.1/build/pure-min.css" integrity="sha384-CCTZv2q9I9m3UOxRLaJneXrrqKwUNOzZ6NGEUMwHtShDJ+nCoiXJCAgi05KfkLGY" crossorigin="anonymous">
  
  
    <link rel="stylesheet" href="https://unpkg.com/purecss@0.6.1/build/grids-responsive-min.css">
  
  <link rel="stylesheet" href="http://blog.innoweb.cn/css/custom.css">

  
  
  <link rel="stylesheet" href="http://blog.innoweb.cn/highlight/styles/default.css">
  
  <script src="http://blog.innoweb.cn/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <meta name="generator" content="Hugo 0.63.2" />
  
</head>
<body>

<div class="header pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
    <div class="pure-u-11-12 pure-u-md-5-8">
        <div class="desktop pure-menu pure-menu-horizontal nav-menu">
            
            <a href="http://blog.innoweb.cn/" class="site-title pure-menu-heading">Fish blog ø</a>
            <ul class="pure-menu-list">
				
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/Algorithm" class="pure-menu-link">Algorithm</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/golang" class="pure-menu-link">Golang</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/vue" class="pure-menu-link">Vue</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/%E7%AE%97%E6%B3%95" class="pure-menu-link">算法</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" class="pure-menu-link">计算机网络</a>
                </li>
                
				
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/about/" class="pure-menu-link">About</a>
                </li>
            </ul>
        </div>
        <div class="mobile pure-menu nav-menu">
            <a href="/" class="pure-menu-heading" id="toggle-home">Fish blog ø</a>
            <a href="#" id="toggle-btn">&#9776;</a>
            <ul class="pure-menu-list" id="toggle-content" style="display:none;">
                
				
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/Algorithm" class="pure-menu-link">Algorithm</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/golang" class="pure-menu-link">Golang</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/vue" class="pure-menu-link">Vue</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/%E7%AE%97%E6%B3%95" class="pure-menu-link">算法</a>
                </li>
                
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" class="pure-menu-link">计算机网络</a>
                </li>
                
				
                <li class="pure-menu-item">
                    <a href="http://blog.innoweb.cn/about" class="pure-menu-link">About</a>
                </li>
            </ul>
        </div>
    </div>
    <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>

<div class="pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
	<div class="pure-u-11-12 pure-u-md-5-8">
        <div class="post">

            <div class="post-title">
                <p class="footnote">
                    <time class="">2020-01-31</time>
		            
                    
                    |
                    
                    
                    tags:<a href="http://blog.innoweb.cn/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">编程基础</a> <a href="http://blog.innoweb.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a> <a href="http://blog.innoweb.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B">自顶向下</a> 
                    

                    
                    categories:<a href="http://blog.innoweb.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a> 
                    

                    
                </p>
                <h1>DRAFT: 自顶向下读书 分组交换</h1>
            </div>

            <div class="post-content">
                <p>计算机网络必定要限制在端系统之间的吞吐量(每秒能够传送的数据盘) ，在端系统之间引入时延，而且实际上能够丢失分组。</p>
<h2 id="时延和丢包">时延和丢包</h2>
<h3 id="分组交换网中的时延概述">分组交换网中的时延概述</h3>
<p>当分组从一个<strong>结点(主机或路由器)<strong>沿着·<strong>后继结点(主机或路由器)</strong>，该分组在沿途的每个结点经受了几种不同类型的时延。这些时延最为重要的是</strong>结点处理时延(nodal processing delay)</strong>、<strong>排队时延(queuing delay)</strong>、<strong>传输时延(ansmission delay)</strong> 和<strong>传播时延 (propagalÍon delay)</strong>，这些时延总体累加起来是<strong>结点总时延(nodal delay)</strong> 。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213958.png" alt="image-20200123164430867"></p>
<h3 id="时延的类型">时延的类型</h3>
<p><strong>传输的条件：</strong></p>
<ul>
<li>路由器 A 具有通往路由器 B 的出链路。</li>
<li>当在该链路没有其他分组正在传输并且没有其他分组排在该队列前面时，才能在这条链路上传输该分组。</li>
</ul>
<h4 id="处理时延">处理时延</h4>
<p>检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。高速路由器的处理时延通常是微秒或更低的数量级。在这种结点处理之后，路由器将该分组引向通往路由器 B 链路之前的队列。</p>
<h4 id="排队时延">排队时延</h4>
<p>在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。</p>
<h4 id="传输时延">传输时延</h4>
<p>假定分组以先到先服务方式传输，这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。用 <code>L</code> 比特表示该分组的长度，用 <code>R bps (即 b/s)</code> 表示从路由器 A 到路由器 B 的链路传输速率。 例如，对于一条 <code>10Mbps</code> 的以太网链路，速率<code>R = 10Mbps</code>; 对于 <code>100Mbps</code> 的以太网链路，速率 <code>R = 100Mbps</code>，传输时延是<code>L/R</code>。这是将所有分组的比特推向链路所需要的时间。</p>
<h4 id="传播时延">传播时延</h4>
<p>从该链路的起点到路由器 B 传播所需要的时间是传播时延。 该比特以该链路的传播速率传播。 该传播速率取决于该链 路的物理媒体(即光纤、双绞铜线等)，其速率等于或略小于光速。该传播时延等于两台路由器之间的距离除以传播速率。即传播时延是d/s，其中 d 是路由器 A 和路由器 B 之间的距离，s是该链路的传播速率。 一旦该分组的最后一个比特传播到结点 B ，该比特及前面的所有比特被存储于路由器 B。 整个过程将随着路由器 B 执行转发而持续下去。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213951.png" alt="image-20200123164444972"></p>
<h4 id="总结">总结</h4>
<p>如果我们令<strong><code>d(prod)、d(queue)、d(trans)、d(prop)</code></strong>分别表示处理时延、排队时延、传输时延和传播时延，则结点的总时延由下式给定:
$$
d_{nodal}~=~d_{prod}~+~d_{queue}~+~d_{trans}~+~d_{prop}
$$
处理时延<code>d(proc)</code>通常是微不足道的，然而，它对一台路由器的最大吞吐量有重要影响，最大吞吐量是一台路由器能够转发分组的最大速率。</p>
<h3 id="排队时延和丢包">排队时延和丢包</h3>
<p><strong>排队时延</strong></p>
<p>结点时延的最为复杂和有趣的成分是排队时延 <code>d(queue)</code>，例如，如果 10 个分组同时到达空队列，传输的第一个分组没有排队时延，而传输的最后一个分组将经受相对大的排队时延(这时它要等待其他9个分组被传输)。因此，当计算排队时延时，人们通常使用统计量测度，如平均排队时延、排队时延的方差和排队时延超过某些特定值的概率。</p>
<p>为了更深入地领会某些要点，令 <code>α</code> 表示<strong><code>分组到达队列的平均速率 (α 的单位是分组/ 秒，即 pkt/s)</code></strong> 。 前面讲过 <code>R</code> 是传输速率，即从队列中<strong><code>推出比特的速率(以 bps 即 b/s 为单位)</code></strong> 。为了简单起见，也假定所有分组都是由 <code>L</code> 比特组成的。 则比特到达队列的平均速率 是 <code>Lα bps</code>。 最后，假定队列非常大，因此它基本能容纳无限数量的比特。<code>比率 Lα/R</code>  称为<strong><code>流量强度( traffic intensity)</code></strong>，它在估计排队时延的范围方面经常起着重要的作用。 如果 <code>La/R &gt; 1</code> ，则 比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，该队列趋向于无界增加，并且排队时延将趋向无穷大！因此流量工程中的一条金科玉律是：<strong>设计系统时流量强度不能大于 1</strong> 。</p>
<p><strong>丢包</strong></p>
<p>我们已经假设队列能够容纳无穷多的分组。在现实中，一条链路前的队列只有有限的容量，尽管<strong>排队容量极大地依赖于路由器设计和成本</strong>。 因为该排队容量是有限的，随着流量强度接近 1 ，排队时延并不实际趋向无穷大。 相反，到达的分组将发现 一个满的队列。 由于没有地方存储这个分组，路由器将<code>丢弃(drop)</code> 该分组，即该分组将会<code>丢失(lost)</code> 。</p>
<h3 id="端到端时延">端到端时延</h3>
<p>我们现在考虑从源到目的地的总时延。 为了能够理解这个概念，假定在源主机和日的主机之间有<code>N-1</code> 台路由器。 我们还要假设该网络此时是无拥塞的(因此排队时延是微不足道的) ，在每台路由器和源主机上的处理时延是<code>d(proc)</code>，每台路由器和源主机的输出速率是<code>R bps</code>，每条链路的传播时延是 <code>d(prop)</code>。 结点时延累加起来，得到端到端时延:
$$
d_{end~to~end}~=~N*(d_{prod}~+~d_{trans}~+~d_{prop})
$$</p>
<h2 id="计算机网络中的吞吐量">计算机网络中的吞吐量</h2>
<h3 id="吞吐量的定义">吞吐量的定义</h3>
<p>为了定义吞吐量，考虑从<strong>主机A</strong>到<strong>主机B</strong>跨越计算机网络传送个大文件。 例如，也许是从一个<strong>P2P文件</strong>共享系统中的一个对等方向另一个对等方传送一个大视频片段。在任何时间瞬间的<strong><code>瞬时吞吐量( instantaneous throughput)</code></strong> 是主机B接收到该文件的速率(以<strong>bps</strong>计)。如果该文件由F比特组成，主机<strong>B</strong>接收到所有<strong>F</strong>比特用去<strong>T</strong>秒，则文件传送的<strong><code>平均吞吐量(average throughput)</code></strong>是<strong><code>F/T bps</code></strong>。对于某些应用程序如因特网电话，希望具有低时延和在某个阈值之上的一致的瞬时吞吐量。</p>
<p>为了进一步深人理解吞吐量这个重要概念，我们考虑几个例子。上图显示了服务器和客户这两个端系统，它们由两条通信链路和一台路由器相连。考虑从服务器传送一个文件到客户的吞吐量。令<strong>Rs</strong>表示服务器与路由器之间的链路速率、<strong>Rc</strong>表示路由器与客户之间的链路速率。假定在整个网络中只有从这台服务器到那台客户的比特在传送。我们可以想象比特是流体，通信链路是管道。显然，这台服务器不能以快于<strong>Rsbps</strong>的速率通过其链路注人比特，这台路由器也不能以快于<strong>Rc bps</strong>的速率转发比特。如果<strong>Rs &lt;Rc</strong>，则由该服务器注人的比特将顺畅地通过路由器“流动&rdquo;，并以速率<strong>Rc bps</strong>到达客户，给定了<strong>Rsbps</strong>的吞吐量。在另方面，如果<strong>Rc &lt; Rs</strong>，则该路由器将不能够以接收它们那样快的速率来转发比特。在这种情况下，比特将以速率<strong>Rs</strong>离开该路由器，从而得到端到端吞吐量<strong>Rs</strong>。(还要注意的是，如果比特继续以速率<strong>Rs</strong>到达该路由器，继续以<strong>Rc</strong>离开路由器的话，在该路由器中等待传输给客户的积压比特将不断增加，这是一种非常不希望的情况!)。因此，对于这种简单的两链路的网络，其吞吐量是<strong>min{Rc，Rs}</strong>，这就是说，它是<strong><code>瓶颈链路(bot一tleneck link)</code></strong>的传输速率。在决定了吞吐量之后，我们现在近似地得到从服务器到客户传输一个<strong>F</strong>比特的大文件所需要的时间是<strong>F/min{Rc，Rs}</strong>。对于一个特定的例子，假定你正在下载一个<strong>F=32x10^6</strong>比特的MP3文件，服务器具有<strong>Rc =2Mbps</strong>的传输速率，并且你有一条<strong>Rs=1Mbps</strong>的接人链路。则传输该文件所需的时间是32秒。当然，这些吞吐量和传送时间的表达式仅是近似的，因为它们并没有考虑分组层次和协议的问题。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213916.png" alt="image-20200124192829603"></p>
<p>下图此时显示了在服务器和客户之间具有N条链路的一个网络，这<strong>N</strong>条链路的传输速率分别是<strong>R1,R2,,,,Rx</strong>。应用与对两条链路网络的分析相同的方法，我们发现从服务器到客户的文件传输的吞吐量是<strong>min{R1, R2, .., RN</strong>}。</p>
<p><img src="http://image.innoweb.cn/2020-01-30-213925.png" alt="image-20200124193451821"></p>
<p>考虑从服务器向客户的文件传送的吞吐量。服务器以速率为<strong>Rs</strong>的接人速率与网络相连，且客户以速率为<strong>Rc</strong>的接入速率与网络相连。现在假定在计算机网络核心中的所有链路具有非常高的传输速率，即该速率比<strong>Rc和Rs</strong>要高得多。目前因特网的核心的确过度装备了高速率的链路，从而很少出现拥塞。同时假定在整个网络中发送的比特都是从该服务器到该客户。在这个例子中，因为计算机网络的核心就像一个宽大的管子，所以比特从服务器向目的地的流动速率仍是Rc和Rs中的最小者，即<strong>吞吐量=min{Rs, Rc}</strong>。因此，在今天因特网中对吞吐量的限制因素通常是接人网。</p>

            </div>
        </div>
	</div>
    <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>

<div class="footer pure-g">
    <div class="pure-u-1-24 pure-u-md-5-24"></div>
    <div class="pure-u-11-12 pure-u-md-5-8">
        <div class="footer-content">
		  <div class="pure-menu pure-menu-horizontal">
              <ul>
			      
                  <li class="pure-menu-heading" id="foot-name">FishMan:</li>
                  
				  
                  
          
                  
                  <li class="pure-menu-item">
                      <a href="https://github.com/https://github.com/patrick-prod" class="pure-menu-link">GitHub</a>
                  </li>
                  
          
                  
                  <li class="pure-menu-item">
                      <a href="https://www.linkedin.com/in/YOUR%20LINKEDIN%20ID" class="pure-menu-link">LinkedIn</a>
                  </li>
                  
          
                  
          
                  
          
              </ul>
              <a href="#" class="pure-menu-heading pull-right" id="gototop-btn">↑↑</a>
          </div>
		  
		  <p id="foot-copyright">Copyright (c) 2008 - 2014, Steve Francia; all rights reserved.</p>
		  
		</div>
	  </div>
      <div class="pure-u-1-24 pure-u-md-1-6"></div>
</div>


<script src="http://blog.innoweb.cn/js/jquery.min.js" type="text/javascript"></script>
<script src="http://blog.innoweb.cn/js/jquery.timeago.js" type="text/javascript"></script>
<script type="text/javascript">
  $(function(){
    $("time.timeago").timeago();
  })
  $("#toggle-btn").click(function(){
    $("#toggle-content").toggle();
    if($(this).html() === "☰") {
        $(this).html("X")
    } else {
        $(this).html("☰")
    }
  });
  $(window).resize(function(){
    if(window.innerWidth > 768) {
      $(".desktop").removeAttr("style");
    }
  });
</script>

</body>
</html>

