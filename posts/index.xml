<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Inno`s Blog</title>
    <link>https://blog.innoweb.cn/posts/</link>
    <description>Recent content in Posts on Inno`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright (c) 2008 - 2014, Steve Francia; all rights reserved.</copyright>
    <lastBuildDate>Wed, 26 Aug 2020 21:09:47 +0800</lastBuildDate>
    
	<atom:link href="https://blog.innoweb.cn/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>我脱单了</title>
      <link>https://blog.innoweb.cn/2020/%E6%88%91%E8%84%B1%E5%8D%95%E4%BA%86/</link>
      <pubDate>Wed, 26 Aug 2020 21:09:47 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E6%88%91%E8%84%B1%E5%8D%95%E4%BA%86/</guid>
      <description>我脱单了，鸽了两个月，咕咕咕咕咕&amp;hellip;</description>
    </item>
    
    <item>
      <title>React&#43;Typescript踩坑集</title>
      <link>https://blog.innoweb.cn/2020/react-typescript%E8%B8%A9%E5%9D%91%E9%9B%86/</link>
      <pubDate>Wed, 26 Aug 2020 20:58:13 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/react-typescript%E8%B8%A9%E5%9D%91%E9%9B%86/</guid>
      <description>最近把自己开发的一个react项目用typescript重构了一遍，使用的技术栈为react+react-redux+react-router，迁移的过程中遇到了很多坑，这就来和大家分享一下。 项目地址</description>
    </item>
    
    <item>
      <title>用deno来快速运行ts代码</title>
      <link>https://blog.innoweb.cn/2020/%E7%94%A8deno%E6%9D%A5%E5%BF%AB%E9%80%9F%E8%BF%90%E8%A1%8Cts%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 06 Jul 2020 21:08:07 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E7%94%A8deno%E6%9D%A5%E5%BF%AB%E9%80%9F%E8%BF%90%E8%A1%8Cts%E4%BB%A3%E7%A0%81/</guid>
      <description>最近博主在用TypeScript来刷题，一开始的时候先通过tsconfig.json配置编译再拿到node里去运行，这个过程不适合很巴适。前一阵子nodejs作者发布的deno可以直接跑ts的语法，配</description>
    </item>
    
    <item>
      <title>JavaScript模块化-AMD</title>
      <link>https://blog.innoweb.cn/2020/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96-AMD/</link>
      <pubDate>Thu, 02 Jul 2020 23:44:17 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96-AMD/</guid>
      <description>最近写一个小游戏的时候用的是RequireJs构建项目，顺便补了一下RequireJs，下面讲解一些基础和进阶的用法。 AMD AMDAsync Module Definition代表的意思为异步模块定义，是Javascript模块化的</description>
    </item>
    
    <item>
      <title>Linux系统服务</title>
      <link>https://blog.innoweb.cn/2020/linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 27 Jun 2020 07:36:08 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</guid>
      <description>最近发现自己service 、chkconfig、systemd这几个命令傻傻分不清，于是就给自己好好科普了一下。 Linux 系统服务 Linux 系统服务也称为守护进程，是在Linux启动时自动加载并在Linux退出时自动</description>
    </item>
    
    <item>
      <title>这个博客是怎么搭出来的</title>
      <link>https://blog.innoweb.cn/2020/%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%98%AF%E6%80%8E%E4%B9%88%E6%90%AD%E5%87%BA%E6%9D%A5%E7%9A%84/</link>
      <pubDate>Sat, 27 Jun 2020 04:56:33 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E6%98%AF%E6%80%8E%E4%B9%88%E6%90%AD%E5%87%BA%E6%9D%A5%E7%9A%84/</guid>
      <description>第一步：hugo的安装和基本使用 第一步先偷个懒，直接挂一个bilibili上的教程（BV1q4411i7gL），up主讲的真的很清楚了，成功的小伙伴别忘了三连。 #bilibili { width: 100%; height: 550px; } @media only screen and (min-device-width: 320px) and (max-device-width: 480px) { #bilibili { width:</description>
    </item>
    
    <item>
      <title>大数相加和大数相乘</title>
      <link>https://blog.innoweb.cn/2020/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98/</link>
      <pubDate>Mon, 15 Jun 2020 01:31:41 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%92%8C%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98/</guid>
      <description>大数相加和大数相乘 所有的语言数字类型都有安全的计算范围，超过范围之后不同语言的处理不同，有可能会报错，也有可能拿不到精确的结果，对javascript来说它的处理是不精确的结果： console.log(123456789 * 987654321) // 121932631112635260 错误结果 对于</description>
    </item>
    
    <item>
      <title>位运算技巧总结</title>
      <link>https://blog.innoweb.cn/2020/%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 04 Jun 2020 17:13:24 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>位运算基础 位操作 是程序设计中对位模式或二进制数的一元和二元操作。在许多古老的微处理器上，位运算比加减运算略快，通常位运算比乘除法运算要快很多。在现代架构中，情况并非如此：位运算的运算速度通常与加法运算</description>
    </item>
    
    <item>
      <title>俄罗斯农民乘法</title>
      <link>https://blog.innoweb.cn/2020/%E4%BF%84%E7%BD%97%E6%96%AF%E5%86%9C%E6%B0%91%E4%B9%98%E6%B3%95/</link>
      <pubDate>Fri, 15 May 2020 18:12:20 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E4%BF%84%E7%BD%97%E6%96%AF%E5%86%9C%E6%B0%91%E4%B9%98%E6%B3%95/</guid>
      <description>龙鸣乘法 在很久很久以前。。。人们是这样做乘法的。。。这是一种古老的乘法算法，但是在如今的计算机中却还能发现它的身影。它，就是以俄罗斯农民命名的乘法算法！ 我们绝大多数人学的都是这样做大数字乘法的： 86 x 57</description>
    </item>
    
    <item>
      <title>跳表的原理与实现</title>
      <link>https://blog.innoweb.cn/2020/%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Wed, 15 Apr 2020 20:14:51 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E8%B7%B3%E8%A1%A8/</guid>
      <description>跳表（skip list） Skip list是一个用于有序元素序列快速搜索的数据结构，由美国计算机科学家William Pugh发明于1989年。它的效率和红黑树以及 AVL 树不相上下，但实现起来比较容易。 作者Will</description>
    </item>
    
    <item>
      <title>Leetcode刷题记录150-200</title>
      <link>https://blog.innoweb.cn/2020/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95150-200/</link>
      <pubDate>Wed, 15 Apr 2020 18:12:57 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95150-200/</guid>
      <description>102. 二叉树的层次遍历 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如: // 给定二叉树: [3,9,20,null,null,15,7] 3 / \ 9 20 / \ 15 7 // 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 我的解法： 层级BFS，做题的时候</description>
    </item>
    
    <item>
      <title>Leetcode刷题记录051 100</title>
      <link>https://blog.innoweb.cn/2020/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95051-100/</link>
      <pubDate>Sat, 14 Mar 2020 22:19:17 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95051-100/</guid>
      <description>56.区间合并 力扣（LeetCode）链接 题目描述： 给出一个区间的集合，请合并所有重叠的区间。 示例: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间</description>
    </item>
    
    <item>
      <title>广度优先遍历与优化</title>
      <link>https://blog.innoweb.cn/2020/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 25 Feb 2020 17:20:39 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>概述 广度优先遍历属于图的一种基本遍历算法，其基本思想是尽最大程度辐射能够覆盖的节点，并对其进行访问。 这里所说的图，不止局限于存储结构上的图，还包括逻辑结构上的图，接下来也会举相对的例子。 以迷宫为例，深</description>
    </item>
    
    <item>
      <title>Leetcode刷题记录001-050</title>
      <link>https://blog.innoweb.cn/2020/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95001-050/</link>
      <pubDate>Wed, 19 Feb 2020 22:49:56 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95001-050/</guid>
      <description>1.两数之和 力扣（LeetCode）链接 题目描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，</description>
    </item>
    
    <item>
      <title>Go编程规范</title>
      <link>https://blog.innoweb.cn/2020/go%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</link>
      <pubDate>Tue, 11 Feb 2020 19:57:37 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/go%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</guid>
      <description>要使用好你的语言，重要的是要了解它的特性和约定。 了解Go编程中已建立的约定（如命名，格式设置，程序构造等）非常重要，这样您编写的程序将易于其他Go程序员理解。以下我们介绍了惯用的Go代码的技巧和语言规</description>
    </item>
    
    <item>
      <title>Go操作kafka</title>
      <link>https://blog.innoweb.cn/2020/go%E6%93%8D%E4%BD%9Ckafka/</link>
      <pubDate>Sat, 08 Feb 2020 07:04:04 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/go%E6%93%8D%E4%BD%9Ckafka/</guid>
      <description>消息概念部分引自李文周的个人博客。 什么叫消息队列💩 消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。 消息队列（Message Queu</description>
    </item>
    
    <item>
      <title>二叉排序树</title>
      <link>https://blog.innoweb.cn/2020/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</link>
      <pubDate>Sat, 01 Feb 2020 17:06:07 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</guid>
      <description>二叉排序树 二叉排序树的基础数据结构当然是一棵二叉树，在二叉树的基础上二叉排序树添加了一些特性，让其自身适合于查找的场景。 规则 若二叉排序树的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的</description>
    </item>
    
    <item>
      <title>Go校验层go-validator</title>
      <link>https://blog.innoweb.cn/2020/go%E6%A0%A1%E9%AA%8C%E5%B1%82go-validator/</link>
      <pubDate>Fri, 31 Jan 2020 22:00:26 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/go%E6%A0%A1%E9%AA%8C%E5%B1%82go-validator/</guid>
      <description>最近在使用iris框架开发应用的时候，框架本身没有提供优秀的校验层，于是找到了一个第三方库go-validator来搭建校验层。 安装 Go get 获取依赖。 go get gopkg.in/validator.v2 Import the package into your own code. import ( &amp;#34;gopkg.in/validator.v2&amp;#34; ) 使用 定义校验规则 自定义你的</description>
    </item>
    
    <item>
      <title>Go处理token</title>
      <link>https://blog.innoweb.cn/2020/go%E5%A4%84%E7%90%86token/</link>
      <pubDate>Fri, 31 Jan 2020 21:34:13 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/go%E5%A4%84%E7%90%86token/</guid>
      <description>搭建网站时我们经常使用JWT做用户鉴权，在golang中我们🉑️以通过jwt-go的第三方库来为我们实现。 常见的处理流程： 从request获取tokenstring，可能是通过cookie携带，也可能</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://blog.innoweb.cn/2020/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Fri, 31 Jan 2020 09:04:57 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>前言 ✍ 动态规划（Dynamic Programming），求解的问题必须有两个性质：最优子结构和子问题重叠，和分治法的思想相同，动态规划的思路也是先将大问题分解成若干个规模相同的子问题，但是动态规划的问</description>
    </item>
    
    <item>
      <title>动态规划模型</title>
      <link>https://blog.innoweb.cn/2020/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 31 Jan 2020 08:33:26 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</guid>
      <description>线性模型 🌾 两个变量之间存在一次方函数关系，就称它们之间存在线性关系。 在线性结构上进行状态转移DP，统称线性DP，注意问题中的未知数只有两个那就是n和f(n)，比如说分金币问题中的coins总数和cha</description>
    </item>
    
    <item>
      <title>贪心算法</title>
      <link>https://blog.innoweb.cn/2020/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 31 Jan 2020 08:18:46 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>简介 贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>https://blog.innoweb.cn/2020/%E9%80%92%E5%BD%92/</link>
      <pubDate>Fri, 31 Jan 2020 08:12:41 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E9%80%92%E5%BD%92/</guid>
      <description>定义 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。在算法中递归应用之广毋庸置疑回溯，分治，动态规划，贪心算法中都推导的过程中可能用到递归算法。比如实际上，递归，</description>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link>https://blog.innoweb.cn/2020/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 31 Jan 2020 08:11:15 +0800</pubDate>
      
      <guid>https://blog.innoweb.cn/2020/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>回溯算法实际上一个类似枚举的搜索尝试过程，是穷举的子集，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 所谓的回溯，其实就是利用了for循环的执行先后顺序，</description>
    </item>
    
  </channel>
</rss>