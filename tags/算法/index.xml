<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 于先森的个人博客</title>
    <link>https://patrick-prod.github.io/tags/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 于先森的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 25 Feb 2020 17:20:39 +0800</lastBuildDate>
    
	<atom:link href="https://patrick-prod.github.io/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>广度优先遍历与优化</title>
      <link>https://patrick-prod.github.io/post/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%B8%8E%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 25 Feb 2020 17:20:39 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%B8%8E%E4%BC%98%E5%8C%96/</guid>
      <description>概述 概述 广度优先遍历属于图的一种基本遍历算法，其基本思想是尽最大程度辐射能够覆盖的节点，并对其进行访问。 这里所说的图，不止局限于存储结构上的图，还包括逻辑结构上的图，接下来也会举相对的例子。 以迷宫为例，深度优先搜索更像是一个人在走迷宫，遇到没有走过就标记，遇到走过就退一步重新走；</description>
    </item>
    
    <item>
      <title>Leetcode刷题记录</title>
      <link>https://patrick-prod.github.io/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Wed, 19 Feb 2020 22:49:56 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</guid>
      <description>1.两数之和 力扣（LeetCode）链接 题目描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1 2 3 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1]</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Fri, 31 Jan 2020 09:04:57 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>前言✍ 动态规划（Dynamic Programming），求解的问题必须有两个性质：最优子结构和子问题重叠，和分治法的思想相同，动态规划的思路也是先将大问题分解成若干个规模相同的子问题，但是动态规划的问题是重叠的，想要理解一个动态规划就要理解一个它的核心，动态规划算法的核心是下面的</description>
    </item>
    
    <item>
      <title>动态规划模型</title>
      <link>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 31 Jan 2020 08:33:26 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E5%9E%8B/</guid>
      <description>线性模型🌾 两个变量之间存在一次方函数关系，就称它们之间存在线性关系。 在线性结构上进行状态转移DP，统称线性DP，注意问题中的未知数只有两个那就是n和f(n)，比如说分金币问题中的coins总数和charge次数。下面拿实际问题来举例子。 注意：已知量数组不属于变量，比如说金币面额。</description>
    </item>
    
    <item>
      <title>贪心算法</title>
      <link>https://patrick-prod.github.io/post/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 31 Jan 2020 08:18:46 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>简介 贪心算法（英语：greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。 例子:最小生成树的算法 (Prim MST</description>
    </item>
    
    <item>
      <title>递归</title>
      <link>https://patrick-prod.github.io/post/%E9%80%92%E5%BD%92/</link>
      <pubDate>Fri, 31 Jan 2020 08:12:41 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E9%80%92%E5%BD%92/</guid>
      <description>定义 在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。在算法中递归应用之广毋庸置疑回溯，分治，动态规划，贪心算法中都推导的过程中可能用到递归算法。比如实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在： 递归就是有去（递去</description>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link>https://patrick-prod.github.io/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 31 Jan 2020 08:11:15 +0800</pubDate>
      
      <guid>https://patrick-prod.github.io/post/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>回溯算法实际上一个类似枚举的搜索尝试过程，是穷举的子集，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 所谓的回溯，其实就是利用了for循环的执行先后顺序，比如同一层循环中，某一次循环断裂掉了，那么下一次循环一定会执行，也就是所谓的回溯</description>
    </item>
    
  </channel>
</rss>